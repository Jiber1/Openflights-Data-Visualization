Our final project for CS 225 was a huge collection of airport and flight data organized by a graph. We then added algorithms to work on this graph and finally a visualizer component which would display the data we acquired on a PNG of a world map.

In order to make sure our project was working as intended. It was imperative that we have tests that made sure our implentation was working how we wanted it to. The different components of our project, parser, graph, BFS, Dijkstra's, and a visualizer, each consisted of their own main.cpp and test directory. Furthermore, the header files and cpp files were divided for further organization.

The parser went over the data files and created Airport and Route objects on the heap. The way to retrieve this list of data was to call functions from the parser and obtain each list appropriately. The graph had two maps which associated airport IDs with the airport itself and another map with airport IDs to maps of destination ID to route Edge objects. Our Dijkstra object takes in a graph and has a function that returns edges in the shortest path between two airports. Our BFS was extended from a traversal object with an iterator we created to allow for multiple traversals. The visualizer is able to draw shortest paths, airports, and routes.

In order to prove our methods work as intended, every component has a test directory that can be run. This will run multiple test case suites for each component to make sure the functionality is working as intended. The test cases were carefully written with a small subset of data to test various conditions that would occur in program. The README.md file describes how these tests can be run to prove our program works as expected.

For our final deliverables, we have multiple test folders that contain both testing data and test suites that make sure each part of the project is working correctly. Each of them can be run within their own folders. The project is structured so that each folder contains subfolders that hold header files, cpp files, test data and test cases, and a main.cpp file that runs that portion of the codebase specifically. The parser main file runs the parser on the data files, and stores the results into an `Airport*` vector and a `Route*` vector. It then prints the size of the vectors to the terminal. The visualizer main file constructs a visualizer object from the graph produced by the data files. It then generates a visualization from two airports and saved the output as `visualmain.png`. The graph main file constructs a graph object from the data files. It then calculates the amount of adjacent airports, or airports with routes that connect them to the source airport, a source airport has, and prints it on the terminal. The BFS main file creates a BFS object from the graph made from the dataset. It then traverses the graph, starting at the airport with an ID of 1. Once it is finished it outputs its results to `bfsOutput.txt`.
